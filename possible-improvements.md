# Conventions for source layout #
You could have some conventions for project source layout.  

You need to write an implementation class for your endpoint, on top of the already 3 *minimum* classes wsimport generates.  If it is only **3** that is awesome, because that also makes this convention much easier.  

**proposed conventions**  are all based on some `default.package.name` that is generated by wsimport defaults. For the 3 classes, and the additional 4th implementation class, the folder grouping can be:

* `default.package.name`
  * SomeServiceInterface.java
  * ObjectFactory.java
  * impl
    * SomeServiceImplementation.java
  * client
    * ClientServiceHelper.java

These aren't going to be their real names.  But the plugin could automatically move everything into these folder(s) and could execute another task to make the client jar from these source layout conventions

# Client jar task #
With the conventions listed above, you can write a jar task to jar the files that the client needs.  It would be easy enough to write a jar task like 

```groovy
jar {
  from sourceSet.main.output
  exclude('default/package/name/impl/*.class')
}
```

# wsdl project name to wsdl name add-ins #
This could be anything, but say you have an additional name convention in your project that `-dm` in a project name denotes a Data Management Service type, and your wsdl name should reflect this is `SomeThingDataManagementService.wsdl`.  

**Currently** the mapping would be 
>  "spock-star-trek-dm-ws"   >> "SpockStarTrekDmService" 

But this additional feature would be configured something like

```groovy
wsdl {
  nameRule = ["-dm":"DataManagement"]
}
```

and you would then get a mapping of 
>  "spock-star-trek-dm-ws"   >> "SpockStarTrekDataManagementService" 

## Going cryptic on ya ##
With the map variable convention, you could have as many name conventions as you want per project if you want to get super cryptic.

# Automatic Episode name finding #
This would couple conventions between this plugin and the jaxb plugin I [wrote](https://github.com/djmijares/gradle-jaxb-namespace-dependency).  But in the parsing of wsdl with wsimport it would be possible to resolve the wsdl dependencies, find the targetNamespace of all the xsd's imported and convert the targetNamespace to an episode file name the same way the other plugin does.  Then you would not have to know which episode files to bind.  It would bind them all. 

**assuming** that you generated them with the other plugin in the same manner or else it wouldn't work quite well.  

it could be configured like

```groovy
wsdl {
 automateEpisodeBinding = true
}
```
